# DBOpt_Course_PaymentData
Задание к курсу Оптимизация баз данных - расчёт балансов


В силу условий программного обеспечения, а именно операционной системы Linux, у нас не было возможности использовать напрямую инструменты взаимодействия с MS SQL Server. Поэтому сам SQL Server был поднять с помощью официального [image с dockerhub](https://hub.docker.com/_/microsoft-mssql-server), а для взаимодействия с СУБД применялся python, DataGrip и Azure Data Studio, VSCode с раширением SQL Server и pyodbc.

Все замеры в текущей работе были усреднены по нескольким запускам.

## Начальные действия
### Разработать и применить генератор тестовых данных

В файле `sql_adapter.py` находится класс для генерации данных с помощью 

`.`

 - Пробовали менять размер пакетов с экспоненциальным увеличением числа записей.  
     - Результаты показали, что размер пакета влияет на скорость выполнения при общем большом количестве записей в запросе вставки. Таким образом, чем больше размер одного пакета, тем быстрее проходит запрос. Эффект усиляется с увеличением общего размера запроса.  
     - Сами результаты замеров можно найти в `logs.txt`, скрипт для замеров `indicies_chunks.py`

 - Пробовали добавить мультипроцессинг для замера производительности генерации.
     - Сначала столкнулись с deadlock'ом операции `SELECT` и `INSERT` (обновления `Payment` и просмотра `PaymentParticipant`) нескольких процессов. 
     - В качестве решения проблемы был использован hint `UPDLOCK`. Это гарантирует, что `SELECT` использует блокировку записи вместо блокировки чтения, что предотвратит эскалацию блокировки между параллельными транзакциями.
     - Результаты расположены в `logs_multiprocessing.txt`, а скрипт для генерации `indicies_multiprocessing.py`. Скорость оказалась ожидаемо меньше последовательного варианта в силу блокировок.


### Разработать простой тест на корректность расчёта баланса

`.`

## Задачи I уровня
 - Пробовали добавлять индексы для полей, которые используются в операциях: 
    - `CalculateBalanceByMaterial`
    - `CalculateRemainderTheAdvance`
    - `CalculatePaymentParticipantBalance`
    - `CalculateBalanceByWork`
    - `CalculateProjectBalance`.  
    Результаты находятся в файле `logs_generated.txt`, а скрипт - `indicies_chunks_generated.py`.  
    По полученным значениям можно судить, то добавленные индексы практически не повлияли на производительность базы данных, поскольку отклонения от результатов для изначальных индексов незначительные и происходят как в отрицательную, так и в положительную сторону.

## Задачи II уровня
В исходной версии балансы обновляются в рамках транзакции целевого действия над платежом - создания или изменения. Предположим, что требования к производительности не выполняются при такой реализации.

Введём две роли пользователей: бухгалтер-оператор и бухгалтер-аналитик.

**Оператор** - занимается вводом и корректировкой платежей, не имеет доступа к данным о балансах.

**Бухгалтер-аналитик** - отслеживает балансы и заведённые платежи для принятия решения о предпринимаемых финансовых действиях (какие счета использовать, какие образовались долги и т.д.).

1. Дать оценку затрат на выполнения операций расчёта балансов в рамках транзакций создания и изменения платежа. Желательно представить количественную оценку, но допустимо и относительную (к примеру, "90% ресурсов и времени уходит на расчёт баланса"). Чем детальнее, тем лучше.
2. Предложить сценарий оптимизации механизмов расчёта. Сценарий должен допускать максимизацию скорости целевых изменений и допускать отложенное вычисление балансов (балансы и данные платежей должны быть согласованы в конечном счёте).
3. Оценить недостатки предлагаемого сценария с точки зрения потенциальных пользователей.
